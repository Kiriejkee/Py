# # Задача No39. Решение в группах
# # Даны два массива чисел. Требуется вывести те элементы первого массива (в том порядке, в каком они идут в первом массиве),
# # которых нет во втором массиве. Пользователь вводит число N - количество элементов в первом массиве, затем N чисел - элементы массива.
# # Затем число M - количество элементов во втором массиве. Затем элементы второго массива
# # Ввод:
# # 7
# # 3 1 3 4 2 4 12
# # 6
# # 4 15 43 1 15 1
# # Вывод:
# # 3 3 2 12
# # (каждое число вводится с новой строки)
import random
#
#
# def find_uniq(arr1, arr2):
#     uniq_elements = []
#     for i in arr1:
#         if i not in arr2:
#             uniq_elements.append(i)
#     return uniq_elements
#
# n = 10
# arr1 = [random.randint(1, 10) for _ in range(n)]
# print(arr1)
# arr2 = [random.randint(1, 10) for _ in range(n)]
# print(arr2)
# print(*find_uniq(arr1,arr2))


# Дан массив, состоящий из целых чисел. Напишите программу, которая в данном массиве определит
#  количество элементов, у которых два соседних и, при этом,
# оба соседних элемента меньше данного. Сначала вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив состоит из целых чисел.
# Ввод: Ввод:
# 55
# 1 2 3 4 5 15151
# Вывод: Вывод:
# 02

# n = 10
# arr1 = [random.randint(1, 10) for _ in range(n)]
#
# def count(arr):
#     counter = 0
#     for i in range(1, len(arr) - 1):
#         if arr[i] > arr[i-1] and arr[i] > arr[i+1]: #arr[i-1] < arr[i] > arr[i+1] Как вариант (множественное сравнение)
#             counter +=1
#     return counter
# print(*arr1)
# print(count(arr1))

# Задача No43. Решение в группах
# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу.
# Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
# Вводится список чисел. Все числа списка находятся на разных строках.
# Ввод: Вывод:
# 1232  3 2


# Задача No45. Решение в группах
# Два различных натуральных числа n и m называются дружественными, если сумма делителей числа n (включая 1, но исключая само n)
# равна числу m и наоборот. Например, 220 и 284 – дружественные числа. По данному числу k выведите все пары дружественных чисел,
# каждое из которых не превосходит k. Программа получает на вход одно натуральное число k, не превосходящее 105.
# Программа должна вывести все пары дружественных чисел, каждое из которых не превосходит k.
# Пары необходимо выводить по одной в строке, разделяя пробелами. Каждая пара должна быть выведена только один раз (перестановка чисел новую пару не дает).
# Ввод: Вывод:
# 300 220 284

def find_sum(n):
    sum = 0
    for i in range(1, n//2 + 1):
        if n % i == 0:
            sum +=i
    return sum
k = 300
list_1 = [(n, find_sum(n)) for n in range(1, k)]
for i in list_1[0]:
    for j in list_1[1]:
        if i == j:
            print(i, j)

# print(find_sum(220)) -- 284
# print(find_sum(284)) -- 220

# n = int(input())
# list_1 = list()
# for i in range(n):
#     summa = 0
#     for j in range(1, i // 2 + 1):
#         if i % j == 0:
#             summa += j
#     list_1.append(tuple([i, summa]))
# for i in range(len(list_1)):
#     for j in range(i, len(list_1)):
#         if i != j and list_1[i][0] == list_1[j][1] and list_1[i][1] == list_1[j][0]:
#             print(*list_1[i])